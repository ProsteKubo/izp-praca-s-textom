#include <stdio.h>#include <string.h>#define ASCII_CHARACTERS 256#define MAX_LETTERS 101#define LOWER_UPPER_DISTANCE ('a' - 'A')char char_to_lower(char input);int output_arr[ASCII_CHARACTERS] = {0};typedef enum  {    NO_INPUT,    SEARCHING,    FULL_MATCH,}  app_state;int main(int argc, char **argv) {    if (argc > 2) {        fprintf(stderr, "Too many characters");        return 1;    }    app_state comparing = argc > 1 ? SEARCHING : NO_INPUT;    char input[comparing == NO_INPUT ? 0 : strlen(argv[1])];    // if input is empty /0 ("")    if (comparing == SEARCHING && strlen(argv[1]) == 0) {        comparing = NO_INPUT;    }    if (comparing) {        unsigned long current_input_position = 0;        for (; current_input_position < strlen(argv[1]); current_input_position++) {            input[current_input_position] = char_to_lower(argv[1][current_input_position]);        }        input[current_input_position] = '\0';    }    char current_city[MAX_LETTERS];    int current_character;    unsigned long city_index = 0;    char last_matched[MAX_LETTERS];    int amount_of_found_cities = 0;    while (1) {        current_character = getchar();        if (city_index > MAX_LETTERS) {            fprintf(stderr, "Line in file has more then 100 chars.\n");            return 1;        }        if (current_character == '\n' || current_character == EOF) {            // guard against null line at the end of the file            if (city_index == 0) {                break;            }            current_city[city_index] = '\0';            city_index = 0;            if (comparing == NO_INPUT) {                output_arr[(int) current_city[0]] = 1;                amount_of_found_cities += 1;            } else {                unsigned long match;                for (match = 0; match < strlen(input);) {                    if (current_city[match] == input[match]) {                        match++;                    } else {                        break;                    }                }                if (match == strlen(current_city) && match == strlen(input)) {                    comparing = FULL_MATCH;                    strcpy(last_matched, current_city);                    amount_of_found_cities = 1;                    break;                } else if (match == strlen(input)) {                    output_arr[(int) current_city[match]] = 1;                    strcpy(last_matched, current_city);                    amount_of_found_cities += 1;                }            }            if (current_character == EOF) {                break;            }        } else {            current_city[city_index++] = char_to_lower(current_character);        }    }    if (comparing == FULL_MATCH || amount_of_found_cities == 1) {        printf("Found: %s", last_matched);    } else if (amount_of_found_cities == 0) {        printf("Not found");    } else {        printf("Enable: ");        for (int i = 0; i < 255; i++) {            if (output_arr[i] == 1) {                printf("%c", (char) i);            }        }    }    return 0;}char char_to_lower(char input)  {    return input >= 'a' && input <= 'z' ? input - LOWER_UPPER_DISTANCE : input;}