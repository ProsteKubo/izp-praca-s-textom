#include <stdio.h>#include <string.h>const short distance_between_lower_and_upper = 'a' - 'A';char char_to_lower(char input);const int max_letters = 101;int output_arr[255]; // all ascii charsenum app_state {    NO_INPUT,    SEARCHING,    FULL_MATCH,};int main(int argc, char **argv) {    enum app_state comparing = argc > 1 ? SEARCHING : NO_INPUT;    char input[comparing == NO_INPUT ? 0 : strlen(argv[1])];    // if input is empty    if (comparing == SEARCHING && strlen(argv[1]) == 0) {        comparing = NO_INPUT;    }    if (comparing) {        unsigned long current_input_position = 0;        for (; current_input_position < strlen(argv[1]); current_input_position++) {            input[current_input_position] = char_to_lower(argv[1][current_input_position]);        }        input[current_input_position] = '\0';    }    char current_city[max_letters];    int current_character;    unsigned long city_index = 0;    char last_matched[max_letters];    int amount_of_found_cities = 0;    while (1) {        current_character = getchar();        if (current_character == '\n' || city_index == sizeof(current_city) - 1 || current_character == EOF) {            // guard against null line at the end of the file            if (city_index == 0) {                break;            }            current_city[city_index] = '\0';            city_index = 0;            if (comparing == NO_INPUT) {                output_arr[(int) current_city[0]] = 1;                amount_of_found_cities += 1;            } else {                unsigned long match;                for (match = 0; match < strlen(input);) {                    if (current_city[match] == input[match]) {                        match++;                    } else {                        break;                    }                }                if (match == strlen(current_city) && match == strlen(input)) {                    comparing = FULL_MATCH;                    strcpy(last_matched, current_city);                    amount_of_found_cities = 1;                    break;                } else if (match == strlen(input)) {                    output_arr[(int) current_city[match]] = 1;                    amount_of_found_cities += 1;                    strcpy(last_matched, current_city);                }            }            if (current_character == EOF) {                break;            }        } else {            current_city[city_index++] = char_to_lower(current_character);        }    }    if (comparing == FULL_MATCH || amount_of_found_cities == 1) {        printf("Found: %s", last_matched);    } else if (amount_of_found_cities == 0) {        printf("Not found");    } else {        printf("Enable: ");        for (int i = 0; i < 255; i++) {            if (output_arr[i] == 1) {                printf("%c", (char) i);            }        }    }    return 0;}char char_to_lower(char input)  {    return input >= 'a' && input <= 'z' ? input - distance_between_lower_and_upper : input;}